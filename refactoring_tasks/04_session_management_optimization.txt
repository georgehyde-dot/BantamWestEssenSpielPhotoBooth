REFACTORING TASK: Session Management Optimization
================================================

OBJECTIVE:
Optimize session management by reducing redundant database operations, extracting story generation logic to a separate service, moving hardcoded content to configuration, and improving the overall session workflow efficiency.

CURRENT PROBLEMS:
1. Multiple database round trips for a single session update
2. Story generation logic tightly coupled to Session struct
3. Hardcoded story templates and content inside the model
4. Inefficient session loading/saving patterns in route handlers
5. No caching mechanism for frequently accessed sessions
6. Session validation logic mixed with data model
7. generate_story() method contains business logic that belongs in a service layer

FILES TO EXAMINE:
- src/session.rs (entire file, especially generate_story method at lines ~180-270)
- src/routes/session_routes.rs (multiple load/save operations)
- src/routes/printer_routes.rs (redundant session loading)
- src/routes/camera_routes.rs (session updates in capture_image)
- Database queries that could be optimized or batched

SPECIFIC ISSUES TO ADDRESS:

1. REDUNDANT DATABASE OPERATIONS:
   ```rust
   // Current pattern in routes:
   let session = Session::load(&id, &pool).await?;
   session.field = some_value;
   session.update(&pool).await?;
   // Later in same request:
   let session = Session::load(&id, &pool).await?;  // Redundant!
   ```

2. HARDCODED CONTENT IN generate_story():
   - Lines defining weapon names: ["sword", "hammer", "pistol", "fire spell"]
   - Lines defining land names: ["misty hills", "abandoned house", etc.]
   - Lines defining companion names: ["clever cat", "loyal dog", etc.]
   - Story templates hardcoded in match statements

3. BUSINESS LOGIC IN DATA MODEL:
   - generate_story() method should not be part of the Session struct
   - Story generation is business logic, not data persistence
   - Validation mixed with data representation

RECOMMENDED SOLUTION STRUCTURE:

1. SEPARATE STORY SERVICE:
   ```rust
   // src/services/story_service.rs
   pub struct StoryService {
       story_config: StoryConfig,
   }

   impl StoryService {
       pub fn generate_story(&self, weapon: i32, land: i32, companion: i32) -> (String, String) {
           // Story generation logic here
       }
   }
   ```

2. STORY CONFIGURATION:
   ```rust
   // src/config.rs - add to existing config
   #[derive(Debug, Clone, Deserialize)]
   pub struct StoryConfig {
       pub weapons: Vec<WeaponConfig>,
       pub lands: Vec<LandConfig>,
       pub companions: Vec<CompanionConfig>,
       pub story_templates: Vec<StoryTemplate>,
   }
   ```

3. SESSION SERVICE LAYER:
   ```rust
   // src/services/session_service.rs
   pub struct SessionService {
       pool: SqlitePool,
       cache: Arc<Mutex<LruCache<String, Session>>>,
   }

   impl SessionService {
       pub async fn get_or_create(&self, id: Option<&str>) -> Result<Session>;
       pub async fn update_fields(&self, id: &str, updates: SessionUpdate) -> Result<Session>;
       pub async fn save_photo(&self, id: &str, photo_path: &str) -> Result<Session>;
   }
   ```

4. OPTIMIZED DATABASE OPERATIONS:
   - Use transactions for multiple updates
   - Implement session caching with TTL
   - Batch updates when possible
   - Use UPDATE queries instead of load/save patterns

IMPLEMENTATION GUIDELINES:

1. EXTRACT STORY GENERATION:
   a. Create services/mod.rs and services/story_service.rs
   b. Move all story generation logic from Session to StoryService
   c. Load story content from configuration files
   d. Make story templates configurable and extensible

2. CREATE SESSION SERVICE:
   a. Implement a service layer for session operations
   b. Add in-memory caching with appropriate TTL
   c. Use database transactions for complex updates
   d. Implement partial updates to avoid full object saves

3. OPTIMIZE ROUTE HANDLERS:
   a. Use session service instead of direct Session methods
   b. Combine multiple operations into single service calls
   c. Remove redundant session loading
   d. Use proper transaction boundaries

4. CONFIGURATION STRUCTURE:
   ```yaml
   # config/story_content.yaml
   weapons:
     - id: 0
       name: "sword"
       description: "gleaming blade"
     - id: 1
       name: "hammer"
       description: "mighty hammer"

   lands:
     - id: 0
       name: "misty hills"
       atmosphere: "mysterious"

   story_templates:
     - weapon_id: 0
       land_id: 0
       template: "With {weapon} drawn and their {companion} by their side..."
   ```

SPECIFIC REFACTORING STEPS:

1. IN session.rs:
   - Remove generate_story() method
   - Remove story generation arrays
   - Keep only data persistence logic
   - Simplify to a pure data model

2. CREATE services/story_service.rs:
   - Move all story generation logic here
   - Load content from configuration
   - Implement template rendering
   - Add story customization options

3. CREATE services/session_service.rs:
   - Implement caching layer
   - Add transaction support
   - Provide high-level operations
   - Handle validation

4. UPDATE routes:
   - Inject SessionService and StoryService
   - Replace direct Session calls with service calls
   - Remove redundant operations
   - Improve error handling

CACHING STRATEGY:
- Use LRU cache with 100 session capacity
- 5-minute TTL for active sessions
- Invalidate on updates
- Write-through cache pattern
- Consider Redis for distributed deployments

BEST PRACTICES TO FOLLOW:
- Separate concerns: data, business logic, and presentation
- Use dependency injection for services
- Keep sessions immutable where possible
- Use transactions for consistency
- Log all database operations
- Monitor cache hit rates
- Make configuration external and versionable

ANTI-PATTERNS TO AVOID:
- Business logic in data models
- Multiple database calls for single operations
- Hardcoded content in source code
- Mixing validation with persistence
- Loading full objects for partial updates
- Ignoring transaction boundaries

VALIDATION CRITERIA:
- Story generation completely extracted from Session
- No hardcoded content in source files
- Database calls reduced by at least 50%
- All routes use service layer
- Configuration is external and documented
- Tests pass with improved performance
- Cache hit rate > 80% for active sessions

PERFORMANCE METRICS TO TRACK:
- Database queries per request
- Average session operation time
- Cache hit/miss rates
- Memory usage with caching
- Story generation time
- Transaction rollback frequency

TESTING REQUIREMENTS:
- Unit tests for StoryService
- Integration tests for SessionService
- Cache behavior tests
- Transaction rollback tests
- Performance benchmarks
- Configuration loading tests
