REFACTORING TASK: Platform-Specific Code Organization
=====================================================

OBJECTIVE:
Reduce the repetitive #[cfg(target_os = "linux")] conditional compilation attributes throughout the codebase by creating a clean platform abstraction layer.

CURRENT PROBLEMS:
1. Every file has dozens of #[cfg(target_os = "linux")] and #[cfg(not(target_os = "linux"))] attributes
2. Stub implementations are scattered across multiple files
3. Code readability is severely impacted by platform conditionals
4. Maintenance is difficult as platform-specific logic is not centralized

FILES TO EXAMINE:
- src/main.rs (lines with #[cfg(target_os = "linux")] - approximately 40+ instances)
- src/camera.rs (entire file is riddled with platform conditionals)
- src/printers.rs (multiple platform-specific implementations)
- src/templates.rs (duplicate implementations for Linux/non-Linux)
- src/routes/*.rs (platform conditionals in route handlers)

SPECIFIC CODE PATTERNS TO REFACTOR:
1. Look for paired patterns like:
   ```rust
   #[cfg(target_os = "linux")]
   use some_crate::SomeType;

   #[cfg(target_os = "linux")]
   pub struct RealImplementation { ... }

   #[cfg(not(target_os = "linux"))]
   pub struct StubImplementation { ... }
   ```

2. Functions with duplicate signatures:
   - Lines where the same function is defined twice with different cfg attributes
   - Example: camera.rs has duplicate Camera struct definitions

RECOMMENDED SOLUTION STRUCTURE:

1. Create a new platform module hierarchy:
   ```
   src/platform/
   ├── mod.rs
   ├── linux/
   │   ├── mod.rs
   │   ├── camera.rs
   │   ├── printer.rs
   │   └── template.rs
   └── stub/
       ├── mod.rs
       ├── camera.rs
       ├── printer.rs
       └── template.rs
   ```

2. Define common traits in platform/mod.rs that both implementations must satisfy

3. Use conditional compilation only at the module level in platform/mod.rs

4. Replace all scattered #[cfg] attributes with clean imports from the platform module

IMPLEMENTATION GUIDELINES:

1. Start by identifying all platform-specific types and functions
2. Create trait definitions that capture the common interface
3. Move Linux-specific implementations to platform/linux/
4. Move stub implementations to platform/stub/
5. Update all imports to use the platform module
6. Test that both Linux and non-Linux builds work correctly

BEST PRACTICES TO FOLLOW:
- Use traits to define platform-agnostic interfaces
- Keep platform-specific code isolated in dedicated modules
- Minimize the use of #[cfg] outside the platform module
- Ensure stub implementations provide meaningful error messages
- Document why certain functionality is platform-specific

EXPECTED BENEFITS:
- Cleaner, more readable code
- Easier to add support for new platforms
- Better separation of concerns
- Reduced code duplication
- Improved maintainability

VALIDATION CRITERIA:
- Count of #[cfg] attributes should be reduced by at least 80%
- All platform-specific logic should be contained in the platform module
- Both Linux and non-Linux builds should compile without warnings
- No functionality should be lost in the refactoring
