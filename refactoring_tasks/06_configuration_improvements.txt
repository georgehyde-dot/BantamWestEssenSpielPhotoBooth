REFACTORING TASK: Configuration System Improvements
==================================================

OBJECTIVE:
Enhance the configuration system to be more robust, type-safe, and maintainable by centralizing all configuration, improving validation, eliminating hardcoded values, and supporting multiple configuration sources.

CURRENT PROBLEMS:
1. Configuration validation is minimal and scattered
2. Default values are defined in multiple places throughout the code
3. Hardcoded paths and values that should be configurable (e.g., font path: "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf")
4. Environment variables are the only configuration source
5. No configuration schema documentation
6. Story content and templates are hardcoded in session.rs
7. No configuration hot-reloading capability
8. Missing configuration for image processing thresholds
9. Incomplete error messages for configuration problems

FILES TO EXAMINE:
- src/config.rs (main configuration module)
- src/templates.rs (hardcoded font path at line ~196)
- src/session.rs (hardcoded story content in generate_story method)
- src/image_processing.rs (magic numbers that should be configurable)
- src/main.rs (configuration initialization)
- Various uses of std::env::var throughout the codebase

SPECIFIC HARDCODED VALUES TO EXTRACT:
1. Font path in templates.rs: "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf"
2. Story weapon names: ["sword", "hammer", "pistol", "fire spell"]
3. Story land names: ["misty hills", "abandoned house", "dusty road", "babbling stream"]
4. Story companion names: ["clever cat", "loyal dog", "wise duck", "noble horse"]
5. All story templates in session.rs
6. Image processing thresholds (MIN_BOX_WIDTH: 160, MIN_BOX_HEIGHT: 120, etc.)
7. Preview stream framerate: 33ms interval
8. Default storage path: "/usr/local/share/photo_booth"

RECOMMENDED CONFIGURATION STRUCTURE:

1. LAYERED CONFIGURATION:
   ```rust
   // Support multiple configuration sources in priority order:
   // 1. Environment variables (highest priority)
   // 2. Configuration file (config.toml or config.yaml)
   // 3. Default values (lowest priority)

   pub struct ConfigBuilder {
       sources: Vec<Box<dyn ConfigSource>>,
   }
   ```

2. COMPREHENSIVE CONFIG STRUCTURE:
   ```rust
   #[derive(Debug, Clone, Deserialize, Serialize)]
   pub struct Config {
       pub server: ServerConfig,
       pub camera: CameraConfig,
       pub storage: StorageConfig,
       pub printer: PrinterConfig,
       pub template: TemplateConfig,
       pub database: DatabaseConfig,
       pub image_processing: ImageProcessingConfig,  // NEW
       pub story_content: StoryContentConfig,       // NEW
       pub ui: UiConfig,                           // NEW
   }

   #[derive(Debug, Clone, Deserialize, Serialize)]
   pub struct ImageProcessingConfig {
       pub min_box_width: u32,
       pub min_box_height: u32,
       pub edge_threshold: u8,
       pub color_diff_threshold: u8,
       pub inpaint_passes: usize,
       // ... other thresholds
   }

   #[derive(Debug, Clone, Deserialize, Serialize)]
   pub struct StoryContentConfig {
       pub weapons: Vec<StoryItem>,
       pub lands: Vec<StoryItem>,
       pub companions: Vec<StoryItem>,
       pub templates: HashMap<String, String>,
   }

   #[derive(Debug, Clone, Deserialize, Serialize)]
   pub struct UiConfig {
       pub preview_fps: u32,
       pub font_paths: FontPaths,
       pub theme: ThemeConfig,
   }
   ```

3. CONFIGURATION FILE FORMAT (config.toml):
   ```toml
   [server]
   host = "0.0.0.0"
   port = 8080

   [camera]
   device = "/dev/video0"
   width = 1920
   height = 1080
   format = "MJPG"

   [storage]
   base_path = "/usr/local/share/photo_booth"
   temp_dir = "/tmp/photo_booth"

   [template]
   header_text = "Essen Spiel '25"
   fonts.primary = "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf"
   fonts.fallback = [
       "/usr/share/fonts/truetype/liberation/LiberationSans-Regular.ttf",
       "/System/Library/Fonts/Helvetica.ttc"
   ]

   [image_processing]
   min_box_width = 160
   min_box_height = 120
   edge_threshold = 50

   [[story_content.weapons]]
   id = 0
   name = "sword"
   display_name = "Gleaming Sword"

   [[story_content.lands]]
   id = 0
   name = "misty_hills"
   display_name = "Misty Hills"
   atmosphere = "mysterious"
   ```

IMPLEMENTATION GUIDELINES:

1. CREATE CONFIGURATION BUILDER:
   ```rust
   impl Config {
       pub fn builder() -> ConfigBuilder {
           ConfigBuilder::new()
               .add_source(DefaultConfig)
               .add_source(FileConfig::new("config.toml"))
               .add_source(EnvConfig::with_prefix("PHOTO_BOOTH"))
       }

       pub async fn load() -> Result<Self, ConfigError> {
           Self::builder()
               .build()
               .await?
               .validate()
       }
   }
   ```

2. IMPLEMENT COMPREHENSIVE VALIDATION:
   ```rust
   impl Config {
       fn validate(self) -> Result<Self, ConfigError> {
           // Validate server
           if self.server.port == 0 {
               return Err(ConfigError::Validation("Server port cannot be 0".into()));
           }

           // Validate paths exist
           if !self.storage.base_path.exists() {
               return Err(ConfigError::Validation(
                   format!("Storage path does not exist: {}", self.storage.base_path.display())
               ));
           }

           // Validate camera settings
           if self.camera.width == 0 || self.camera.height == 0 {
               return Err(ConfigError::Validation("Camera dimensions cannot be 0".into()));
           }

           // Validate story content
           if self.story_content.weapons.is_empty() {
               return Err(ConfigError::Validation("At least one weapon must be configured".into()));
           }

           Ok(self)
       }
   }
   ```

3. CONFIGURATION DOCUMENTATION:
   ```rust
   // Generate configuration documentation
   impl Config {
       pub fn generate_schema() -> serde_json::Value {
           // Use schemars to generate JSON schema
       }

       pub fn generate_example() -> String {
           // Generate example config file
       }
   }
   ```

4. HOT RELOADING SUPPORT:
   ```rust
   pub struct ConfigWatcher {
       config: Arc<RwLock<Config>>,
       watcher: notify::Watcher,
   }

   impl ConfigWatcher {
       pub async fn watch(path: PathBuf) -> Result<Self, ConfigError> {
           // Watch config file for changes
           // Reload and validate on change
           // Update Arc<RwLock<Config>>
       }
   }
   ```

MIGRATION STEPS:

1. PHASE 1 - EXTEND CURRENT CONFIG:
   - Add new config sections to existing Config struct
   - Keep backward compatibility with env vars
   - Add validation methods

2. PHASE 2 - EXTRACT HARDCODED VALUES:
   - Move font paths to configuration
   - Extract story content to config files
   - Configure image processing thresholds
   - Make all paths configurable

3. PHASE 3 - IMPLEMENT CONFIG SOURCES:
   - Add TOML/YAML file support
   - Implement layered configuration
   - Add configuration builder pattern

4. PHASE 4 - IMPROVE DEVELOPER EXPERIENCE:
   - Generate example configuration
   - Add configuration validation CLI command
   - Implement configuration schema generation
   - Add hot-reloading support

BEST PRACTICES TO FOLLOW:
- Use serde's default attribute for optional configs
- Validate configuration at startup, fail fast
- Provide helpful error messages for misconfigurations
- Document all configuration options
- Use type-safe configuration structures
- Support multiple configuration formats
- Make configuration testable
- Version configuration schemas

ANTI-PATTERNS TO AVOID:
- Don't scatter default values throughout code
- Don't use unwrap() on environment variables
- Don't hardcode paths or values
- Don't skip validation
- Don't use stringly-typed configuration
- Don't make configuration mutable after startup
- Don't mix configuration with runtime state

VALIDATION CRITERIA:
- No hardcoded values in source code
- All configuration has defaults
- Configuration validates at startup
- Clear error messages for invalid config
- Example configuration file provided
- All features configurable
- Tests for configuration validation
- Documentation for all options

TESTING REQUIREMENTS:
- Unit tests for configuration validation
- Tests for each configuration source
- Tests for configuration merging
- Tests for missing required values
- Tests for invalid values
- Integration tests with full config
- Performance tests for config loading
