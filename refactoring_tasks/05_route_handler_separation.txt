REFACTORING TASK: Route Handler Separation of Concerns
=====================================================

OBJECTIVE:
Refactor route handlers to follow clean architecture principles by separating HTTP concerns from business logic, creating a proper service layer, and establishing consistent patterns across all routes.

CURRENT PROBLEMS:
1. Route handlers directly perform database operations
2. Business logic is embedded within HTTP request/response handling
3. File system operations are performed directly in routes
4. Duplicate code patterns across similar routes (e.g., print_photo and preview_print)
5. Inconsistent error handling and response formats
6. No clear boundary between web layer and application layer
7. Testing is difficult due to tight coupling
8. Route handlers are doing too many things (violating Single Responsibility Principle)

FILES TO EXAMINE:
- src/routes/camera_routes.rs (capture_image mixing file I/O, DB operations, and HTTP)
- src/routes/printer_routes.rs (print_photo and preview_print have duplicate logic)
- src/routes/session_routes.rs (all handlers directly interact with database)
- src/routes/base_routes.rs (could benefit from a view rendering service)
- src/routes/selection_routes.rs (simple but could follow consistent patterns)

SPECIFIC CODE SMELLS:

1. MIXED RESPONSIBILITIES IN capture_image:
   ```rust
   // Current anti-pattern:
   pub async fn capture_image(...) -> impl Responder {
       std::fs::create_dir_all(&config.storage.base_path).ok(); // File system
       let session = Session::load(&session_id, &db_pool).await; // Database
       let img = image::load_from_memory(&bytes); // Image processing
       HttpResponse::Ok().json(response_json) // HTTP response
   }
   ```

2. DUPLICATE LOGIC IN PRINTER ROUTES:
   - print_photo and preview_print share 90% of the same code
   - Both load sessions, validate files, create templates
   - Only difference is final action (print vs. return URL)

3. DIRECT DATABASE ACCESS:
   - Every session route directly uses SqlitePool
   - No abstraction layer for database operations
   - SQL queries could be centralized

RECOMMENDED ARCHITECTURE:

1. SERVICE LAYER STRUCTURE:
   ```
   src/services/
   ├── mod.rs
   ├── camera_service.rs
   ├── printer_service.rs
   ├── session_service.rs
   ├── storage_service.rs
   └── template_service.rs
   ```

2. ROUTE HANDLER PATTERN:
   ```rust
   // Routes should only handle HTTP concerns
   pub async fn capture_image(
       camera_service: web::Data<CameraService>,
       body: web::Json<CaptureRequest>,
   ) -> Result<HttpResponse, AppError> {
       let result = camera_service.capture_photo(body.into_inner()).await?;
       Ok(HttpResponse::Ok().json(result))
   }
   ```

3. SERVICE INTERFACE EXAMPLE:
   ```rust
   // src/services/camera_service.rs
   pub struct CameraService {
       storage: Arc<StorageService>,
       session_service: Arc<SessionService>,
       image_processor: Arc<ImageProcessor>,
   }

   impl CameraService {
       pub async fn capture_photo(&self, request: CaptureRequest) -> Result<CaptureResponse, AppError> {
           // All business logic here
       }
   }
   ```

IMPLEMENTATION GUIDELINES:

1. CREATE SERVICE MODULES:
   a. Start with SessionService (most used)
   b. Create StorageService for file operations
   c. Build CameraService combining storage and processing
   d. Extract PrinterService with template logic
   e. Create TemplateService for print template generation

2. REFACTOR ROUTES INCREMENTALLY:
   a. Start with simple routes (selection_routes.rs)
   b. Move to session_routes.rs
   c. Tackle complex routes (camera_routes.rs)
   d. Finish with printer_routes.rs

3. ESTABLISH PATTERNS:
   ```rust
   // Consistent route pattern
   #[post("/endpoint")]
   pub async fn route_handler(
       service: web::Data<ServiceType>,
       request: web::Json<RequestType>,
   ) -> Result<HttpResponse, AppError> {
       // 1. Validate request
       let validated = request.into_inner().validate()?;

       // 2. Call service
       let result = service.process(validated).await?;

       // 3. Return response
       Ok(HttpResponse::Ok().json(result))
   }
   ```

4. REQUEST/RESPONSE TYPES:
   ```rust
   // Define clear DTOs for each endpoint
   #[derive(Deserialize, Validate)]
   pub struct CaptureRequest {
       #[validate(length(min = 1))]
       pub session_id: Option<String>,
   }

   #[derive(Serialize)]
   pub struct CaptureResponse {
       pub ok: bool,
       pub path: String,
       pub redirect: String,
   }
   ```

SPECIFIC REFACTORING TASKS:

1. FOR camera_routes.rs:
   - Extract file system operations to StorageService
   - Move image processing to CameraService
   - Create CaptureRequest/Response DTOs
   - Simplify route to just HTTP handling

2. FOR printer_routes.rs:
   - Create PrinterService with shared logic
   - Extract template generation to TemplateService
   - Unify print_photo and preview_print through service
   - Create PrintRequest/PreviewRequest DTOs

3. FOR session_routes.rs:
   - Move all database operations to SessionService
   - Create DTOs for each operation
   - Implement proper validation
   - Standardize response formats

4. FOR base_routes.rs:
   - Consider creating ViewService for HTML rendering
   - Or keep simple if no business logic needed

DEPENDENCY INJECTION SETUP:
```rust
// In main.rs
let storage_service = Arc::new(StorageService::new(config.storage.clone()));
let session_service = Arc::new(SessionService::new(db_pool.clone()));
let camera_service = Arc::new(CameraService::new(
    storage_service.clone(),
    session_service.clone(),
));

// Register with Actix
.app_data(web::Data::from(camera_service))
.app_data(web::Data::from(session_service))
```

BEST PRACTICES TO FOLLOW:
- Routes should be thin - just HTTP adapters
- Services contain all business logic
- Use dependency injection for services
- Define clear interfaces with DTOs
- Services should be testable in isolation
- Use Result types consistently
- Validate input at the route layer
- Transform errors to HTTP responses consistently

ANTI-PATTERNS TO AVOID:
- Don't access database directly from routes
- Don't perform file I/O in routes
- Don't duplicate business logic across routes
- Don't mix concerns in a single function
- Don't use unwrap() in production code
- Don't expose internal types in HTTP responses

VALIDATION CRITERIA:
- Each route handler is under 20 lines
- No database access in route files
- No file system operations in route files
- All business logic in service layer
- Consistent error handling across all routes
- DTOs defined for all endpoints
- Services are unit testable
- Integration tests still pass

TESTING STRATEGY:
- Unit test services with mocked dependencies
- Integration test routes with real services
- Test error cases explicitly
- Verify HTTP status codes
- Test request validation
- Mock external dependencies (printer, camera)

MIGRATION APPROACH:
1. Create service layer without changing routes
2. Write tests for new services
3. Gradually replace route logic with service calls
4. Remove old code once all tests pass
5. Refactor tests to use services directly
